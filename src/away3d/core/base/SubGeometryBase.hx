package away3d.core.base;

	//import away3d.arcane;
	import away3d.core.base.ISubGeometry;
	import away3d.core.managers.Stage3DProxy;
	import away3d.errors.AbstractMethodError;
	
	import flash.display3D.Context3D;
	import flash.display3D.IndexBuffer3D;
	import flash.display3D.VertexBuffer3D;
	import away3d.geom.Matrix3D;
	import flash.geom.Vector3D;
	
	import flash.Vector;
	
	//use namespace arcane;
	
	class SubGeometryBase
	{
		var _parentGeometry:Geometry;
		var _vertexData:Array<Float>;
		
		var _faceNormalsDirty:Bool;
		var _faceTangentsDirty:Bool;
		var _faceTangents:Array<Float>;
		var _indices:Array<UInt>;
		var _indexBuffer:Array<IndexBuffer3D>;
		var _numIndices:UInt;
		var _indexBufferContext:Array<Context3D>;
		var _indicesInvalid:Array<Bool>;
		var _numTriangles:UInt;
		
		var _autoDeriveVertexNormals:Bool;
		var _autoDeriveVertexTangents:Bool;
		var _autoGenerateUVs:Bool;
		var _useFaceWeights:Bool;
		var _vertexNormalsDirty:Bool;
		var _vertexTangentsDirty:Bool;
		
		var _faceNormals:Array<Float>;
		var _faceWeights:Array<Float>;
		
		var _scaleU:Float;
		var _scaleV:Float;
		
		var _uvsDirty:Bool;
		
		public function new()
		{
			_indexBuffer = new Array<IndexBuffer3D>();
			
			_indexBufferContext = new Array<Context3D>();
			_indicesInvalid = new Array<Bool>();
			
			_autoDeriveVertexNormals = true;
			_autoDeriveVertexTangents = true;
			_autoGenerateUVs = false;
			_useFaceWeights = false;
			_vertexNormalsDirty = true;
			_vertexTangentsDirty = true;
			_scaleU = 1;
			_scaleV = 1;
		
			_uvsDirty = true;
		}
		
		/**
		 * Defines whether a UV buffer should be automatically generated to contain dummy UV coordinates.
		 * Set to true if a geometry lacks UV data but uses a material that requires it, or leave as false
		 * in cases where UV data is explicitly defined or the material does not require UV data.
		 */
		public var autoGenerateDummyUVs(get, set) : Bool;
		public function get_autoGenerateDummyUVs() : Bool
		{
			return _autoGenerateUVs;
		}
		
		public function set_autoGenerateDummyUVs(value:Bool) : Bool
		{
			_autoGenerateUVs = value;
			_uvsDirty = value;
			return _autoGenerateUVs;
		}
		
		/**
		 * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
		 * explicitly.
		 */
		public var autoDeriveVertexNormals(get, set) : Bool;
		public function get_autoDeriveVertexNormals() : Bool
		{
			return _autoDeriveVertexNormals;
		}
		
		public function set_autoDeriveVertexNormals(value:Bool) : Bool
		{
			_autoDeriveVertexNormals = value;
			
			_vertexNormalsDirty = value;
			return _autoDeriveVertexNormals;
		}
		
		/**
		 * Indicates whether or not to take the size of faces into account when auto-deriving vertex normals and tangents.
		 */
		public var useFaceWeights(get, set) : Bool;
		public function get_useFaceWeights() : Bool
		{
			return _useFaceWeights;
		}
		
		public function set_useFaceWeights(value:Bool) : Bool
		{
			_useFaceWeights = value;
			if (_autoDeriveVertexNormals)
				_vertexNormalsDirty = true;
			if (_autoDeriveVertexTangents)
				_vertexTangentsDirty = true;
			_faceNormalsDirty = true;
			return _useFaceWeights;
		}
		
		/**
		 * The total amount of triangles in the SubGeometry.
		 */
		public var numTriangles(get, null) : UInt;
		public function get_numTriangles() : UInt
		{
			return _numTriangles;
		}
		
		/**
		 * Retrieves the VertexBuffer3D object that contains triangle indices.
		 * @param context The Context3D for which we request the buffer
		 * @return The VertexBuffer3D object that contains triangle indices.
		 */
		public function getIndexBuffer(stage3DProxy:Stage3DProxy):IndexBuffer3D
		{
			var contextIndex:Int = stage3DProxy._stage3DIndex;
			var context:Context3D = stage3DProxy._context3D;
			
			if (_indexBuffer[contextIndex]==null || _indexBufferContext[contextIndex] != context) {
				_indexBuffer[contextIndex] = context.createIndexBuffer(_numIndices);
				_indexBufferContext[contextIndex] = context;
				_indicesInvalid[contextIndex] = true;
			}
			if (_indicesInvalid[contextIndex]) {
				_indexBuffer[contextIndex].uploadFromVector(Vector.ofArray(_indices), 0, _numIndices);
				_indicesInvalid[contextIndex] = false;
			}
			
			return _indexBuffer[contextIndex];
		}
		
		/**
		 * Updates the tangents for each face.
		 */
		private function updateFaceTangents():Void
		{
			var i:UInt = 0;
			var index1:UInt, index2:UInt, index3:UInt;
			var len:UInt = _indices.length;
			var ui:UInt, vi:UInt;
			var v0:Float;
			var dv1:Float, dv2:Float;
			var denom:Float;
			var x0:Float, y0:Float, z0:Float;
			var dx1:Float, dy1:Float, dz1:Float;
			var dx2:Float, dy2:Float, dz2:Float;
			var cx:Float, cy:Float, cz:Float;
			var vertices:Array<Float> = _vertexData;
			var uvs:Array<Float> = UVData;
			var posStride:Int = vertexStride;
			var posOffset:Int = vertexOffset;
			var texStride:Int = UVStride;
			var texOffset:Int = UVOffset;
			
			if (_faceTangents==null) _faceTangents = new Array<Float>();
			
			while (i < len) {
				index1 = _indices[i];
				index2 = _indices[i + 1];
				index3 = _indices[i + 2];
				
				ui = texOffset + index1*texStride + 1;
				v0 = uvs[ui];
				ui = texOffset + index2*texStride + 1;
				dv1 = uvs[ui] - v0;
				ui = texOffset + index3*texStride + 1;
				dv2 = uvs[ui] - v0;
				
				vi = posOffset + index1*posStride;
				x0 = vertices[vi];
				y0 = vertices[vi + 1];
				z0 = vertices[vi + 2];
				vi = posOffset + index2*posStride;
				dx1 = vertices[vi] - x0;
				dy1 = vertices[vi + 1] - y0;
				dz1 = vertices[vi + 2] - z0;
				vi = posOffset + index3*posStride;
				dx2 = vertices[vi] - x0;
				dy2 = vertices[vi + 1] - y0;
				dz2 = vertices[vi + 2] - z0;
				
				cx = dv2*dx1 - dv1*dx2;
				cy = dv2*dy1 - dv1*dy2;
				cz = dv2*dz1 - dv1*dz2;
				denom = 1/Math.sqrt(cx*cx + cy*cy + cz*cz);
				_faceTangents[i++] = denom*cx;
				_faceTangents[i++] = denom*cy;
				_faceTangents[i++] = denom*cz;
			}
			
			_faceTangentsDirty = false;
		}
		
		/**
		 * Updates the normals for each face.
		 */
		private function updateFaceNormals():Void
		{
			var i:UInt = 0, j:UInt = 0, k:UInt = 0;
			var index:UInt;
			var len:UInt = _indices.length;
			var x1:Float, x2:Float, x3:Float;
			var y1:Float, y2:Float, y3:Float;
			var z1:Float, z2:Float, z3:Float;
			var dx1:Float, dy1:Float, dz1:Float;
			var dx2:Float, dy2:Float, dz2:Float;
			var cx:Float, cy:Float, cz:Float;
			var d:Float;
			var vertices:Array<Float> = _vertexData;
			var posStride:Int = vertexStride;
			var posOffset:Int = vertexOffset;
			
			if (_faceNormals==null) _faceNormals = new Array<Float>();
			if (_useFaceWeights)
				if (_faceWeights==null) _faceWeights = new Array<Float>();
			
			while (i < len) {
				index = posOffset + _indices[i++]*posStride;
				x1 = vertices[index];
				y1 = vertices[index + 1];
				z1 = vertices[index + 2];
				index = posOffset + _indices[i++]*posStride;
				x2 = vertices[index];
				y2 = vertices[index + 1];
				z2 = vertices[index + 2];
				index = posOffset + _indices[i++]*posStride;
				x3 = vertices[index];
				y3 = vertices[index + 1];
				z3 = vertices[index + 2];
				dx1 = x3 - x1;
				dy1 = y3 - y1;
				dz1 = z3 - z1;
				dx2 = x2 - x1;
				dy2 = y2 - y1;
				dz2 = z2 - z1;
				cx = dz1*dy2 - dy1*dz2;
				cy = dx1*dz2 - dz1*dx2;
				cz = dy1*dx2 - dx1*dy2;
				d = Math.sqrt(cx*cx + cy*cy + cz*cz);
				// length of cross product = 2*triangle area
				if (_useFaceWeights) {
					var w:Float = d*10000;
					if (w < 1)
						w = 1;
					_faceWeights[k++] = w;
				}
				d = 1/d;
				_faceNormals[j++] = cx*d;
				_faceNormals[j++] = cy*d;
				_faceNormals[j++] = cz*d;
			}
			
			_faceNormalsDirty = false;
		}
		
		/**
		 * Updates the vertex normals based on the geometry.
		 */
		private function updateVertexNormals(target:Array<Float>):Array<Float>
		{
			if (_faceNormalsDirty)
				updateFaceNormals();
			
			var v1:UInt;
			var f1:UInt = 0, f2:UInt = 1, f3:UInt = 2;
			var lenV:UInt = _vertexData.length;
			var normalStride:Int = vertexNormalStride;
			var normalOffset:Int = vertexNormalOffset;
			
			if (target==null) target = new Array<Float>();
			v1 = normalOffset;
			while (v1 < lenV) {
				target[v1] = 0.0;
				target[v1 + 1] = 0.0;
				target[v1 + 2] = 0.0;
				v1 += normalStride;
			}
			
			var i:UInt = 0, k:UInt = 0;
			var lenI:UInt = _indices.length;
			var index:UInt;
			var weight:Float;
			
			while (i < lenI) {
				weight = _useFaceWeights? _faceWeights[k++] : 1;
				index = normalOffset + _indices[i++]*normalStride;
				target[index++] += _faceNormals[f1]*weight;
				target[index++] += _faceNormals[f2]*weight;
				target[index] += _faceNormals[f3]*weight;
				index = normalOffset + _indices[i++]*normalStride;
				target[index++] += _faceNormals[f1]*weight;
				target[index++] += _faceNormals[f2]*weight;
				target[index] += _faceNormals[f3]*weight;
				index = normalOffset + _indices[i++]*normalStride;
				target[index++] += _faceNormals[f1]*weight;
				target[index++] += _faceNormals[f2]*weight;
				target[index] += _faceNormals[f3]*weight;
				f1 += 3;
				f2 += 3;
				f3 += 3;
			}
			
			v1 = normalOffset;
			while (v1 < lenV) {
				var vx:Float = target[v1];
				var vy:Float = target[v1 + 1];
				var vz:Float = target[v1 + 2];
				var d:Float = 1.0/Math.sqrt(vx*vx + vy*vy + vz*vz);
				target[v1] = vx*d;
				target[v1 + 1] = vy*d;
				target[v1 + 2] = vz*d;
				v1 += normalStride;
			}
			
			_vertexNormalsDirty = false;
			
			return target;
		}
		
		/**
		 * Updates the vertex tangents based on the geometry.
		 */
		private function updateVertexTangents(target:Array<Float>):Array<Float>
		{
			if (_faceTangentsDirty)
				updateFaceTangents();
			
			var i:UInt = 0;
			var lenV:UInt = _vertexData.length;
			var tangentStride:Int = vertexTangentStride;
			var tangentOffset:Int = vertexTangentOffset;
			
			if (target==null) target = new Array<Float>();
			
			i = tangentOffset;
			while (i < lenV) {
				target[i] = 0.0;
				target[i + 1] = 0.0;
				target[i + 2] = 0.0;
				i += tangentStride;
			}
			
			var k:UInt = 0;
			var lenI:UInt = _indices.length;
			var index:UInt;
			var weight:Float;
			var f1:UInt = 0, f2:UInt = 1, f3:UInt = 2;
			
			i = 0;
			
			while (i < lenI) {
				weight = _useFaceWeights? _faceWeights[k++] : 1;
				index = tangentOffset + _indices[i++]*tangentStride;
				target[index++] += _faceTangents[f1]*weight;
				target[index++] += _faceTangents[f2]*weight;
				target[index] += _faceTangents[f3]*weight;
				index = tangentOffset + _indices[i++]*tangentStride;
				target[index++] += _faceTangents[f1]*weight;
				target[index++] += _faceTangents[f2]*weight;
				target[index] += _faceTangents[f3]*weight;
				index = tangentOffset + _indices[i++]*tangentStride;
				target[index++] += _faceTangents[f1]*weight;
				target[index++] += _faceTangents[f2]*weight;
				target[index] += _faceTangents[f3]*weight;
				f1 += 3;
				f2 += 3;
				f3 += 3;
			}
			
			i = tangentOffset;
			while (i < lenV) {
				var vx:Float = target[i];
				var vy:Float = target[i + 1];
				var vz:Float = target[i + 2];
				var d:Float = 1.0/Math.sqrt(vx*vx + vy*vy + vz*vz);
				target[i] = vx*d;
				target[i + 1] = vy*d;
				target[i + 2] = vz*d;
				i += tangentStride;
			}
			
			_vertexTangentsDirty = false;
			
			return target;
		}
		
		public function dispose():Void
		{
			disposeIndexBuffers(_indexBuffer);
			_indices = null;
			_indexBufferContext = null;
			_faceNormals = null;
			_faceWeights = null;
			_faceTangents = null;
			_vertexData = null;
		}
		
		/**
		 * The raw index data that define the faces.
		 *
		 * @private
		 */
		public var indexData(get, null) : Array<UInt>;
		public function get_indexData() : Array<UInt>
		{
			return _indices;
		}
		
		/**
		 * Updates the face indices of the SubGeometry.
		 * @param indices The face indices to upload.
		 */
		public function updateIndexData(indices:Array<UInt>):Void
		{
			_indices = indices;
			_numIndices = indices.length;
			
			var numTriangles:Int = Std.int(_numIndices/3);
			if (_numTriangles != numTriangles)
				disposeIndexBuffers(_indexBuffer);
			_numTriangles = numTriangles;
			invalidateBuffers(_indicesInvalid);
			_faceNormalsDirty = true;
			
			if (_autoDeriveVertexNormals)
				_vertexNormalsDirty = true;
			if (_autoDeriveVertexTangents)
				_vertexTangentsDirty = true;
		}
		
		/**
		 * Disposes all buffers in a given vector.
		 * @param buffers The vector of buffers to dispose.
		 */
		private function disposeIndexBuffers(buffers:Array<IndexBuffer3D>):Void
		{
			// For loop conversion - 			for (var i:Int = 0; i < 8; ++i)
			var i:Int;
			for (i in 0...8) {
				if (buffers[i]!=null) {
					buffers[i].dispose();
					buffers[i] = null;
				}
			}
		}
		
		/**
		 * Disposes all buffers in a given vector.
		 * @param buffers The vector of buffers to dispose.
		 */
		private function disposeVertexBuffers(buffers:Array<VertexBuffer3D>):Void
		{
			// For loop conversion - 			for (var i:Int = 0; i < 8; ++i)
			var i:Int;
			for (i in 0...8) {
				if (buffers[i]!=null) {
					buffers[i].dispose();
					buffers[i] = null;
				}
			}
		}
		
		/**
		 * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
		 * explicitly.
		 */
		public var autoDeriveVertexTangents(get, set) : Bool;
		public function get_autoDeriveVertexTangents() : Bool
		{
			return _autoDeriveVertexTangents;
		}
		
		public function set_autoDeriveVertexTangents(value:Bool) : Bool
		{
			_autoDeriveVertexTangents = value;
			
			_vertexTangentsDirty = value;
			return _autoDeriveVertexTangents;
		}
		
		/**
		 * The raw data of the face normals, in the same order as the faces are listed in the index list.
		 *
		 * @private
		 */
		public var faceNormals(get, null) : Array<Float>;
		public function get_faceNormals() : Array<Float>
		{
			if (_faceNormalsDirty)
				updateFaceNormals();
			return _faceNormals;
		}
		
		/**
		 * Invalidates all buffers in a vector, causing them the update when they are first requested.
		 * @param buffers The vector of buffers to invalidate.
		 */
		private function invalidateBuffers(invalid:Array<Bool>):Void
		{
			// For loop conversion - 			for (var i:Int = 0; i < 8; ++i)
			var i:Int;
			for (i in 0...8)
				invalid[i] = true;
		}
		
		public var UVStride(get, null) : UInt;
		
		public function get_UVStride() : UInt
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var vertexData(get, null) : Array<Float>;
		
		public function get_vertexData() : Array<Float>
		{
			throw new AbstractMethodError();
			return null;
		}
		
		public var vertexPositionData(get, null) : Array<Float>;
		
		public function get_vertexPositionData() : Array<Float>
		{
			throw new AbstractMethodError();
			return null;
		}
		
		public var vertexNormalData(get, null) : Array<Float>;
		
		public function get_vertexNormalData() : Array<Float>
		{
			throw new AbstractMethodError();
			return null;
		}
		
		public var vertexTangentData(get, null) : Array<Float>;
		
		public function get_vertexTangentData() : Array<Float>
		{
			throw new AbstractMethodError();
			return null;
		}
		
		public var UVData(get, null) : Array<Float>;
		
		public function get_UVData() : Array<Float>
		{
			throw new AbstractMethodError();
			return null;
		}
		
		public var vertexStride(get, null) : UInt;
		
		public function get_vertexStride() : UInt
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var vertexNormalStride(get, null) : UInt;
		
		public function get_vertexNormalStride() : UInt
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var vertexTangentStride(get, null) : UInt;
		
		public function get_vertexTangentStride() : UInt
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var vertexOffset(get, null) : Int;
		
		public function get_vertexOffset() : Int
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var vertexNormalOffset(get, null) : Int;
		
		public function get_vertexNormalOffset() : Int
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var vertexTangentOffset(get, null) : Int;
		
		public function get_vertexTangentOffset() : Int
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		public var UVOffset(get, null) : Int;
		
		public function get_UVOffset() : Int
		{
			throw new AbstractMethodError();
			return 0;
		}
		
		private function invalidateBounds():Void
		{
			if (_parentGeometry!=null)
				_parentGeometry.invalidateBounds(cast(this, ISubGeometry));
		}
		
		/**
		 * The Geometry object that 'owns' this SubGeometry object.
		 *
		 * @private
		 */
		public var parentGeometry(get, set) : Geometry;
		public function get_parentGeometry() : Geometry
		{
			return _parentGeometry;
		}
		
		public function set_parentGeometry(value:Geometry) : Geometry
		{
			_parentGeometry = value;
			return _parentGeometry;
		}
		
		/**
		 * Scales the uv coordinates
		 * @param scaleU The amount by which to scale on the u axis. Default is 1;
		 * @param scaleV The amount by which to scale on the v axis. Default is 1;
		 */
		public var scaleU(get, null) : Float;
		public function get_scaleU() : Float
		{
			return _scaleU;
		}
		
		public var scaleV(get, null) : Float;
		
		public function get_scaleV() : Float
		{
			return _scaleV;
		}
		
		public function scaleUV(scaleU:Float = 1, scaleV:Float = 1):Void
		{
			var offset:Int = UVOffset;
			var stride:Int = UVStride;
			var uvs:Array<Float> = UVData;
			var len:Int = uvs.length;
			var ratioU:Float = scaleU/_scaleU;
			var ratioV:Float = scaleV/_scaleV;
			
			// For loop conversion - 						for (var i:UInt = offset; i < len; i += stride)
			
			var i:UInt = offset;
			
			while (i<len) {
				uvs[i] *= ratioU;
				uvs[i + 1] *= ratioV;
				i += stride;
			}
			
			_scaleU = scaleU;
			_scaleV = scaleV;
		}
		
		/**
		 * Scales the geometry.
		 * @param scale The amount by which to scale.
		 */
		public function scale(scale:Float):Void
		{
			var vertices:Array<Float> = UVData;
			var len:UInt = vertices.length;
			var offset:Int = vertexOffset;
			var stride:Int = vertexStride;
			
			// For loop conversion - 						for (var i:UInt = offset; i < len; i += stride)
			
			var i:UInt = 0;
			
			for (i in offset...len) {
				vertices[i] *= scale;
				vertices[i + 1] *= scale;
				vertices[i + 2] *= scale;
			}
		}
		
		public function applyTransformation(transform:Matrix3D):Void
		{
			var vertices:Array<Float> = _vertexData;
			var normals:Array<Float> = vertexNormalData;
			var tangents:Array<Float> = vertexTangentData;
			var posStride:Int = vertexStride;
			var normalStride:Int = vertexNormalStride;
			var tangentStride:Int = vertexTangentStride;
			var posOffset:Int = vertexOffset;
			var normalOffset:Int = vertexNormalOffset;
			var tangentOffset:Int = vertexTangentOffset;
			var len:UInt = Std.int(vertices.length/posStride);
			var i:UInt, i1:UInt, i2:UInt;
			var vector:Vector3D = new Vector3D();
			
			var bakeNormals:Bool = normals != null;
			var bakeTangents:Bool = tangents != null;
			var invTranspose:Matrix3D = new Matrix3D();
			
			if (bakeNormals || bakeTangents) {
				invTranspose = transform.clone();
				invTranspose.invert();
				invTranspose.transpose();
			}
			
			var vi0:Int = posOffset;
			var ni0:Int = normalOffset;
			var ti0:Int = tangentOffset;
			
			// For loop conversion - 						for (i = 0; i < len; ++i)
			
			for (i in 0...len) {
				i1 = vi0 + 1;
				i2 = vi0 + 2;
				
				// bake position
				vector.x = vertices[vi0];
				vector.y = vertices[i1];
				vector.z = vertices[i2];
				vector = transform.transformVector(vector);
				vertices[vi0] = vector.x;
				vertices[i1] = vector.y;
				vertices[i2] = vector.z;
				vi0 += posStride;
				
				// bake normal
				if (bakeNormals) {
					i1 = ni0 + 1;
					i2 = ni0 + 2;
					vector.x = normals[ni0];
					vector.y = normals[i1];
					vector.z = normals[i2];
					vector = invTranspose.deltaTransformVector(vector);
					vector.normalize();
					normals[ni0] = vector.x;
					normals[i1] = vector.y;
					normals[i2] = vector.z;
					ni0 += normalStride;
				}
				
				// bake tangent
				if (bakeTangents) {
					i1 = ti0 + 1;
					i2 = ti0 + 2;
					vector.x = tangents[ti0];
					vector.y = tangents[i1];
					vector.z = tangents[i2];
					vector = invTranspose.deltaTransformVector(vector);
					vector.normalize();
					tangents[ti0] = vector.x;
					tangents[i1] = vector.y;
					tangents[i2] = vector.z;
					ti0 += tangentStride;
				}
			}
		}
		
		private function updateDummyUVs(target:Array<Float>):Array<Float>
		{
			_uvsDirty = false;
			
			var idx:UInt, uvIdx:UInt;
			var stride:Int = UVStride;
			var skip:Int = stride - 2;
			var len:UInt = Std.int(_vertexData.length/vertexStride*stride);
			
			if (target==null)
				target = new Array<Float>();
			
			// TODO Assess the impact of .fixed and .length properties
			//target.fixed = false;
			//target.length = len;
			//target.fixed = true;
			
			idx = UVOffset;
			uvIdx = 0;
			while (idx < len) {
				target[idx++] = uvIdx*.5;
				target[idx++] = 1.0 - (uvIdx & 1);
				idx += skip;
				
				if (++uvIdx == 3)
					uvIdx = 0;
			}
			
			return target;
		}
	}

